## This reposistory is created with learning purposes for Terraform, focusing on provisioners.

## Purpose :

- It provides a simple example of how to create AWS instance using terraform and provision it.

## What is provisioner ? :

- Provisioner is part of Terraform that is used to configure and setup the resources that have been created by Terraform. In this repository `file` and `remote-exec` provisioners are being used to provision the deployed instance.
- Providers connect to the AWS instance by using SSH key pair. The pair can be generated by using `ssh-keygen` command, it is going to place your public and private keys here : `/Users/USERNAME/.ssh/` (MacOS Mojave). The default names are `id_rsa` for the newly generated private key and `id_rsa.pub` for the public key.

## Warning about provisioners :

- Provisioners are used to configure the newly deployed infrastructure, but they should do minimum amount of work for provisioning, the hard work should be done before deploying the instance. For example, if AWS instance with `nginx` is needed, the `nginx` should be pre-installed in the AMI itself, otherwise if this is done by using a provisioner of Terraform, `nginx` is going to be installed on every instance that is created, which is very time consuming. 

## How to install terraform : 

- The information about installing terraform can be found on the HashiCorp website 
[here](https://learn.hashicorp.com/terraform/getting-started/install.html)

## How to use it :

- In a directory of your choice, clone the github repository 
```
git clone https://github.com/martinhristov90/terraformProvisioners.git
```

- Change into the directory
```
cd terraformProvisioners
```

- It is good practice to have a separate user that Terraform is going to perform actions with, more information [how to create a user in AWS](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users.html)

- set AWS credentials as environemental variables, as decribed [here](https://www.terraform.io/docs/providers/aws/index.html#environment-variables)

```
export AWS_ACCESS_KEY_ID="anaccesskey"
export AWS_SECRET_ACCESS_KEY="asecretkey"
```

- Use your favorite text editor to modify the file `main.tf`. Set the following values :
    - `ami` - The AMI ID to be used.
    - `instance_type` - The size that you desire.
    - `subnet_id`  - Sets the subnet in which the instance is going to be attaced.
    - `vpc_security_group_ids` - Sets the ID of the security group.

- After all the values of the variables are set correctly, go ahead and execute `terraform init`. 
The output should look like this :

    ```shell
        --- SNIP ---

        * provider.aws: version = "~> 2.11"

        Terraform has been successfully initialized!

        --- SNIP ---
    ```
    
- Now, Terraform has downloded the AWS provider for you automatically.

- To preview what is going to happen without actually performing any actions, execute `terraform plan`. The output should look like this :

```shell
------------------------------------------------------------------------

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  + module.server.aws_instance.web
      id:                                <computed>
      ami:                               "ami-0444fa3496fb4fab2"
      get_password_data:                 "false"
      instance_type:                     "t2.micro"
      key_name:                          "${aws_key_pair.training.id}"
      source_dest_check:                 "true"
      subnet_id:                         "subnet-2f591701"
      tags.%:                            "1"
      tags.name:                         "MYMACHINE"
      tenancy:                           <computed>
      volume_tags.%:                     <computed>
      vpc_security_group_ids.#:          "1"
      vpc_security_group_ids.2189854857: "sg-3ddbcb64"

  + module.server.aws_key_pair.training
      id:                                <computed>
      fingerprint:                       <computed>
      key_name:                          "MYMACHINE-key"
      public_key:                        "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7nAP569M/DPWuLdSlIBaTIIWlRS8rJd47cE5pKL5jNTb80R22wIgiiDVJbQs5zmfK45xIxDZVAl84w1c+Ww/2ZbgMyV7rWAhg86Wdlo45pGQLG9Bbz3YddeGNe3S1rlmgUe1jQObDRP3poQ6GH7QiTBiL0VkNp2HhL0GaEP4059A8FuJLSbsEsJQGoXpycsqoaM/ltNCfvf96CD8tviEOCQQHGl6EOeJtU6KdesWjqA0+T6IACfWcCeYKw1VpuU0dhN4T0agi3vjk2LLs3DiyslYxNNEqwaoi1AHYtoKqyXJ2U8CUXAqvaYGDk9QJbgBjbejPtuhwy81b1Gt4EBnJ martinhristov@Martins-MBP.lan"


Plan: 2 to add, 0 to change, 0 to destroy.
```

## What is going to happen? :

- If you review file `server/main.tf` it has two providers defined :
```
provisioner "file" {
source = "./test.sh"
destination = "/tmp/"
}
```
```
provisioner "remote-exec" {
inline = [ 
    "sudo service nginx enable"
]
}
```

The first one is going to copy the shell script named `test.sh` into the instances's `/tmp` folder. The second one is going to enable the `nginx` server. Another interesting part is :

```
connection {
user = "ubuntu"
private_key = "${file("~/.ssh/id_rsa")}"
}
```

It used to establish the needed SSH connection for the providers to function correctly. 

- If everything looks good, execute `terraform apply` to actually provision the resources defined in `server/main.tf`.

- Now you should have a running instance in AWS.

- In order to destroy whatever resources have been created by Terraform, execute `terraform destroy`. 


